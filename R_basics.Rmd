---
title: "Introduction to Data Science"
author: "Victor Coppin"
date: "2025-06-24"
output: 
  html_document:
    toc: true # Enables the table of contents in the rendered HTML
    toc_depth: 2 #Include headings up to ## level in the ToC
    number_sections: true #Adds automatic numbering to headers
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

This file follows the course [*Introduction to Data Science by Rafael A. Irizarry*](Introduction%20to%20Data%20Science.pdf)

R was developed by statisticians as an interactive environment for data analysis   
[Click here to read the History of R (PDF)](historyofS.pdf)  
- R is free and open source
- It runs on all major platforms : Windows, macOS, UNIX/Linux
- Scripts and data objects can be shared seamlessly across platforms
- Active community : [Free resources for learning R](https://stats.stackexchange.com/questions/138/free-resources-for-learning-r) 

## Installation and packages 

### Scripts and Markdown

- **Create a new Script (.R)**: `Ctrl + Shift + N`  
- **Save a Script or R Markdown file**: `Ctrl + S`

### Packages 

To install packages, inside the Console :  

```r
install.packages("ggplot2") # install the ggplot2 library
install.packages("dslabs") # install the Harvard dslabs R package
installed.packages()[,"Package"] #list all installed packages
install.packages("tidyverse", dependencies = TRUE) # tells R to install the other things that are necessary for the package or packages to run smoothly. 
install.packages(c("tidyverse", "dslabs")) # to install two packages at the same time
"ggplot2" %in% rownames(installed.packages()) # return TRUE if a package is already installed.
```

Note: 
"We recommend installing packages through RStudio, rather than through R, and the code provided works in both R and RStudio. Once a package has been installed, it is technically added onto R (even if you use RStudio to install it), which is why packages must be re-installed when R is updated. However, since we use R through RStudio, any packages that are installed can be used in both R and RStudio, regardless of which one was used to install the packages"^[Source: *Introduction to Data Science* by Rafael A. Irizarry].



Load a package into the R session 
Note :  
- to create a chunk code block  : `Ctrl + Alt + I`
- to run a chunk : `Ctrl + Shift + Enter`
- Hides messages (*i.e.* from library calls) : `{r, message=FALSE}`
```{r, message=FALSE}
library(dslabs)
```

### Running commands

#### shortcuts: 

- **Run an entire script**: `Ctrl + Shift + Enter`
- **Run a single line of script**: `Ctrl+Enter` while the cursor is pointing to that specific line.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(dslabs)
data(murders)

murders %>%
  ggplot(aes(population,total, label=abb, color=region ))+
  geom_label()

```
# R Basics

## Objects

### Variables 
To define a variable we may use the assignment symbol: `<-`  


Code to solve the equation : $x^2 + x - 1 = 0$
The quadratic formula gives us the solutions :
$$
\dfrac{-b-\sqrt{b^2-4ac}}{2a} \quad \text{and} \quad \dfrac{-b+\sqrt{b^2-4ac}}{2a} 
$$

```{r}
# assigning values to the variables
a <- 1
b <- 1
c <- -1

#solving the quadratic equation
(-b +sqrt(b^2-4*a*c))/(2*a)
(-b -sqrt(b^2-4*a*c))/(2*a)

```

To see the value stored in a variable we ask R to evaluate `a` or more explicitly to show us the value with the `print()` function  
All the variables are saved in the workspace: `ls()` shows the names of the objects saved.

```{r}
a
print(a)
ls()
```


### Functions

>"R includes several predefined functions and most of the analysis pipelines we construct make extensive use of these.
There are many more prebuilt functions and even more can be added through packages. These functions do not appear in the workspace because you did not define them, but they are available for immediate use.
In general, **we need to use parentheses** to evaluate a function. If you type ls, the function is not evaluated and instead R shows you the code that defines the function. If you type ls() the function is evaluated and, as seen above, we see objects in the workspace. Unlike ls, most functions require one or more arguments. Below is an example of how we assign an object to the argument of the function log."

```{r}
log(8)
log(a) #a was already assigned to 1
```

#### Help 

You can find out what the function expects and what it does by reviewing the very useful manuals included in R. 
```r
help("log")
?log # shorthand
```

>"The help page will show you what arguments the function is expecting. For example, log needs x and base to run. However, some arguments are required and others are optional. You can determine which arguments are optional by noting in the help document that a default value is assigned with =. Defining these is optional. For example, the base of the function log defaults to base = exp(1) making log the natural log by default."

```{r}
args(log) #quick look at the argument without opening the help system
```

If no argument name is used, R assume arguments are in the order shown in the help page: 

```{r}
log(x=8,base=2)
log(base=2, x=8) # if using arguments' names, we can include them in whatever order we want. 
log(8,2)
```

#### Arithmetic and relational operators 

Arithmetic and relational operators are functions that didn't need parentheses to be evaluated. 
Note: In R, operators like `+`, `*`, or `%%` are actually functions, so you can call `help("+")` just like any function.

```r
5+3 
5-1
5*3
10/2
2**2  # Exponentiation
2^3   # Exponentiation
5%%2  # Modulo 
5%/%5 # Integer division

# Help for operators
help("+") # Give a list of all arithmetic operator not only "+"  
?">"      # Help for all relational operators

```

### Other pre-built objects


- Mathematical constants like $\pi$ and $\infty$ are represented as `pi` and `Inf` in R
- List all the available data sets : `data()`
  These data sets are objects that can be used by simply typing the name :`co2`

#### Sequence Generation

Generate regular sequence
```{r}

seq(0, 10)              # generates a sequence from 0 to 10 by 1
seq(0, 100, by = 10)    # from 0 to 100, incrementing by 10
seq(0, 1, length.out = 11) # generates 11 equally spaced numbers from 0 to 1
```

#### Sum

The `sum()` function returns the total of all values present in its arguments.

```{r}
x <- 10
y <- seq(0,x,by =1)
sum(y)
```

```{r}
sum(1:4) # pass a vector to sum and it will add the elements together
```


## Data types

Variables in R can be of different types.The function class helps us determine what type of object we have:
```{r}
a <- 4
class(a) 
```

### Data Frame

>The most common way of storing a dataset in R is in a data frame. Conceptually, we can think of a data frame as a table with rows representing observations and the different variables reported for each observation defining the columns. Data frames are particularly useful for datasets because we can combine **different data types into one object**.

>A large proportion of data analysis challenges start with data stored in a data frame. For example, we stored the data for our motivating example in a data frame. You can access this dataset by loading the dslabs library and loading the murders dataset using the data function:

The `data()` function without arguments lists available datasets from currently loaded packages.
To actually load a dataset, use it with the dataset name: `data(murders)`


```{r, message=FALSE,warning=FALSE}
library(dslabs)
data(murders) # load the dataset "murders" into the environments (memory) allowing to work directly with
```

```{r}
class(murders) # check if murders is indeed a data.frame
```

#### Structure of an object

The function `str` shows us the structure of an object : 

```{r}
str(murders)
library(dplyr)
glimpse(murders) # For compact data view 
```

We can see that murders is a `data.frame` with 51 observations of 5 variables :
- `$state`: a character variable like "Alabama"
- `$abb` : character variable as the abbreviation of the state name
- `$region` : factor, useful to store categorical data and more efficient than storing characters
- `$population` and `$total` are numeric data 


#### The accessor : $
For our analysis, we will need to access the different variables represented by columns included in this data frame. To do this, we use the accessor operator `$`


```{r}
# Showing the first 6 lines of the dataset
head(murders)

# Using the accessor operator to obtain the population column
murders$state

# Determining how many entries are in a vector 
pop <- murders$population
length(pop)

# Factors are another type of class : 
class(murders$region)
levels(murders$region)


```

#### Vectors: numerics, characters and logical

The object `murder$population` is not one number but several, it is a numeric vector of length 51.
To store character strings, vectors can also be of class character. For example, the state names are characters:

```{r}
class(murders$state)
```

Logical vectors : TRUE/FALSE

```{r}
z <- 3 == 2 # == is a relational operator, asking if 3 is equal to 2
z
class(z)
```

#### Factors 

We saw that in the murders data set, region is a factor of 4 levels.

```{r}
levels(murders$region) 
```

>In the background, R stores these levels as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters. Note that the levels have an order that is different from the order of appearance in the factor object. The default is for the levels to follow alphabetical order. However, often we want the levels to follow a different order.
The function reorder lets us change the order of the levels of a factor variable based on a summary computed on a numeric vector.

**Reorder the levels of the region by the total number of murders rather than the alphabetical order**: 
```{r}
region <- murders$region
value <- murders$total 
region <- reorder(region,value, FUN = sum)
levels(region)
```


